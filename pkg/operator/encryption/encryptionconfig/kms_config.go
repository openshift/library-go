package encryptionconfig

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"hash/fnv"
	"sort"
	"strconv"
	"strings"
	"time"

	"k8s.io/apimachinery/pkg/runtime/schema"

	configv1 "github.com/openshift/api/config/v1"
)

const (
	// KMSPluginEndpointFmt holds the unix socket path where the KMS plugin would be run
	// uniquely distinguished by the kms plugin hash
	KMSPluginEndpointFmt = "unix:///var/kube-kms/%s/socket.sock"

	// KMSPluginTimeout fixed timeout
	KMSPluginTimeout = 5 * time.Second
)

// shortHash returns the 32-bit FNV-1a hash
func shortHash(s string) string {
	hash := fnv.New32a()
	hash.Write([]byte(s))
	intHash := hash.Sum32()
	result := fmt.Sprintf("%08x", intHash)
	return result
}

// resourceHash hashes GR names into a short hash.
// This function can input multiple resource names at based on upstream apiserverconfigv1.ResourceConfiguration
// but in our controllers we only support one GR per provider.
func resourceHash(grs ...schema.GroupResource) string {
	res := make([]string, len(grs))
	for i, gr := range grs {
		res[i] = gr.String()
	}
	sort.Strings(res)
	return shortHash(strings.Join(res, "+"))
}

// generateKMSProviderName generates key name for current kms provider
func generateKMSProviderName(generation uint64, kmsHash string, gr schema.GroupResource) string {
	return fmt.Sprintf("%s-%d-%s-%s", "kms", generation, kmsHash, resourceHash(gr))
}

// extractKMSFromProviderName extracts the keyId for strings generated by generateKMSKeyName
func extractKMSFromProviderName(providerName string) (kmsHash string, generation uint64, ok bool) {
	g := strings.TrimLeft(providerName, "kms-")
	v := strings.Split(g, "-")

	if len(v) < 2 {
		return "", 0, false
	}

	kmsHash = v[1]
	generation, err := strconv.ParseUint(v[0], 10, 0)
	return kmsHash, generation, err == nil
}

// encodeConfig is type unaware, re-used in tests
func encodeConfig[T any](config *T) ([]byte, error) {
	return json.Marshal(config)
}

// decodeConfig is type unaware, re-used in tests
func decodeConfig[T any](encodedBytes []byte) (config *T, err error) {
	err = json.Unmarshal(encodedBytes, &config)
	if err != nil {
		return nil, err
	}
	return config, nil
}

// EncodeKMSConfig encodes kms config into json format
func EncodeKMSConfig(cfg *configv1.KMSConfig) ([]byte, error) {
	return encodeConfig(cfg)
}

// DecodeKMSConfig decodes json into a kms config
func DecodeKMSConfig(encodedBytes []byte) (cfg *configv1.KMSConfig, err error) {
	return decodeConfig[configv1.KMSConfig](encodedBytes)
}

// HashKMSConfig returns a short FNV 64-bit hash for a KMSConfig struct
func HashKMSConfig[T any](cfg T) (string, error) {
	hasher := fnv.New64a()
	hasher.Reset()

	encoded, err := encodeConfig(&cfg)
	if err != nil {
		return "", fmt.Errorf("could not generate hash for KMS config: %v", err)
	}

	fmt.Fprintf(hasher, "%s", encoded)
	return hex.EncodeToString(hasher.Sum(nil)[0:]), nil
}
